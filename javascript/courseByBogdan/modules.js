// модули, классы и прототипы


// модули позволяют структурировать код
// модули позволяют избегать дублирование кода

// синтаксис: export, import
// вывод только в терминале, расширение mjs

// можно переименовывать переменные в импорте с помощью интсрукции as
// можно экспортировать несколько методов

// правила: 
// 1. модули должны быть одноцелевыми 
// 2. все экспорты должны быть внизу
// 3. по возможности использовать export default


// классы и прототипы
// на основе классов можно создавать шаблоны-заготовки для объектов, а потом создавать экземпляры
// классы позволяют создавать прототипы для объектов
// на основании прототипов создаются экземпляры
// каждые экземпляры имеют свои собственные свойства и методы
// экземпляры наследуют свойства и методы прототипов
// классы в js - это некая надстройка над методами и функциями
// класс - это шаблон для создания экземпляров класса

// при создании класса слздается прототип, которым будет являться свойствопеременной(название класса)


// в этом классе находятся свойства и методы
// constructor и upvote - это методы
// constructor создает новый экземпляр объекта
// в кргуглых скобках находятся опциональные параметры
// переменная this указывает на экземпляр класса 
// this автоматически ссылается на новый экземпляр класса 
// с помощью переменной this, которая ссылается на конкретный экземпляр класса, можно менять собственные свойства и методы конкретного экземпляра
// при вызове метода класса его экземпляром переменная this будет динамически ссылать на экземпляр, который вызвал метод
// у нового экземпляра класса появится новое свойство с переданным значением 
// по своей сути class Comment является прототипов для объекта класса 
// Comment.prototype - это объект, со всеми методами класса 
// Comment.prototype.constructor === Comment
// на уровне прототипа есть все методы, помимо constructor
// constructor - это метод объекта(Object), он вызывается при создании объекта класса 
// Object наследует методы автоматически
class Comment
{
    constructor(text)           // при вызове данного метода будет передаваться значение text (строка)
    {
        this.text = text        // значение свойства text бует равняться переданному значению text(this.text - это свойство метода, значени которого(text) будет равняться переданному параметру text аргументу)
        this.voteQty = 0
    }

    upvote()
    {
        this.voteQty += 1
    }

}

// создание экземпляра класса (new - это ключевое слово)
// объект унаследованный от класса получает все его методы, их необяхательно применять, но они унаследованы, их можно вызывать
// метод upvote будет виден у экземпляра класса firstText на уровне прототипа

// КОГДА НА УРОВНЕ ЭКЗЕМПЛЯРА, ОБЪЕКТА КЛАССА ВЫЗЫВАЕТСЯ МЕТОД upvote, ТО ВНУТРИ МЕТОДА upvote this БУДЕТ УКАЗЫВАТЬ НА ТОТ ОБЪЕКТ, ГДЕ ВЫЗЫВАЕТСЯ МЕТОД 
// МЕНЯЯ ЗНАЧЕНИЕ СВОЙСТВА, ОНО БУДЕТ МЕНЯТЬСЯ В ОБЪЕКТЕ, КОТОРЫЙ ВЫЗВАЛ МЕТОД БЛАГОДАРЯ THIS

const firstText = new Comment('First comment')
const secondText = new Comment('Second comment')

console.log(firstText)
console.log(secondText)

// проверка принадлежности экземпляра 
firstText instanceof Comment // true

// наследование по цепочке прототипов
// firstText -> Comment -> Object(глобальный класс js)
firstText.upvote()
console.log(firstText.voteQty)

firstText.upvote()
console.log(firstText.voteQty)

console.log(firstText)

// метод hasOwnProperty наследуется от класса Object
// проверка принадлежности того или иного свойства экземпляру класса 
firstText.hasOwnProperty('text')    // true


// в классе можно создавать классические методы
// статисечкий метод не наследуется для экземпляра класса, но он является свойтсвом класса Comment
class Comment1
{
    constructor(text)           // при вызове данного метода будет передаваться значение text (строка)
    {
        this.text = text        // значение свойства text бует равняться переданному значению text(this.text - это свойство метода, значени которого(text) будет равняться переданному параметру text аргументу)
        this.voteQty = 0
    }

    upvote()
    {
        this.voteQty += 1
    }

    static mergeComment(first, second)
    {
        return `${first} ${second}`
    }

}
// собственно вызов этого метода 
Comment1.mergeComment('First lol', 'Second lol')


// также существует расширение классов
// Array - это родительский класс для этого класса, родительский constructor вызывается автоматически
// el - это элемент массива, а acc - это аккумулятор, переменная которая изменяется в процессе итераций массива(там стоит значение 0 для acc)
// цепочка пртотипов: myArray -> NumberArray -> Array -> Object
class NumberArray extends Array 
{
    sum()
    {
        return this.reduce((el, acc) => acc += el, 0)
    }
}

const myArray = new NumberArray(2, 4 ,5)

console.log(myArray)
console.log(myArray.sum())


// у каждого экземпляра класса есть скпытое свойство __proto__, благодаря ему создается вся цепочка прототипов
// всегда класс Comment.prototype === firstComment.__proto__

// переменные со строкой или числом будут как объект, экземпляр класса 